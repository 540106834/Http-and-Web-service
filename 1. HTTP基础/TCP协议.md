# **真正深入且系统化的 TCP 协议详解**

TCP（Transmission Control Protocol）是一个 **面向连接、可靠、有序、基于字节流** 的传输层协议。

它解决的是：**如何在不可靠的 IP 层上构建可靠的通信**。



#  目录

1. TCP 的核心特性
2. TCP 报文段结构（Header）
3. 三次握手（建立连接）
4. 四次挥手（断开连接）
5. 序列号、确认号、ACK、窗口
6. 分段与重传机制（超时、快速重传）
7. 流量控制（滑动窗口）
8. 拥塞控制（四种算法）
9. TIME_WAIT、CLOSE_WAIT 问题
10. 实战抓包分析（Wireshark 视角）

---

# 1️ **TCP 的核心特性**

| 特性       | 解释               |
| -------- | ---------------- |
| **面向连接** | 必须 3 次握手建立连接     |
| **可靠传输** | 序列号 + 确认号 + 重传机制 |
| **有序传输** | 接收端按序组装乱序数据      |
| **流量控制** | 根据对端处理能力调整发送速度   |
| **拥塞控制** | 根据网络负载调整发送速度     |
| **全双工**  | 双向可以同时传数据        |

---

# 2️ **TCP 报文结构（Header）**

```
0      4      8           16                24               31
+------+------+--------------+---------------+----------------+
|    Source Port             |   Dest Port                   |
+------------------------------------------------------------+
|                        Sequence Number                     |
+------------------------------------------------------------+
|                    Acknowledgment Number                   |
+------------------+-----+------+----------------------------+
| Data Offset      |Rsvd |Flags |    Window Size             |
+------------------+-----+------+----------------------------+
|    Checksum      | Urgent Pointer                          |
+------------------------------------------------------------+
|   Options ...                                           ...
+------------------------------------------------------------+
|   Data ...                                             ...
```

关键字段：

* **Seq**：发送数据的字节序号
* **Ack**：期望接收下一字节的序号
* **Window**：流量控制
* **Flags**：

  * SYN：建立连接
  * ACK：确认
  * PSH：立即处理
  * FIN：关闭连接
  * RST：强制断开
* **Options**：

  * MSS（每段最大长度）
  * Window Scale（窗口扩展）
  * Timestamp（重传判断重要）

---

# 3️ **三次握手 — 建立连接**

```
Client → SYN → Server
Client ← SYN+ACK ← Server
Client → ACK → Server
```

### 目的：

1. 双方确认收发能力
2. 双方同步初始序列号 ISN
3. 建立可靠全双工连接

---

# 4️ **四次挥手 — 断开连接**

```
Client → FIN → Server
Client ← ACK ← Server
Server → FIN → Client
Server ← ACK ← Client
```

为什么 4 次？

* 因为关闭连接是单向的，需要 **双方分别发送 FIN**。

---

# 5️ **序列号、确认号、ACK、窗口**

### **序列号（Sequence Number）**

* 标识每个字节的编号（不是包编号）
* 发送多少字节，Seq 就增加多少

### **确认号（Acknowledgement Number）**

* Ack = 期望接收的下一字节序号
* 即“我已经安全收到你哪些数据”

### **ACK 标志**

* 一旦建立连接，每个包几乎都带 ACK

### **窗口（Window Size）**

* 告诉对方自己还能接收多少数据（流量控制）

---

# 6️ **TCP 重传机制（可靠性核心）**

TCP 有 **多层重传**：

### **① 超时重传（RTO：Retransmission Timeout）**

* 根据 RTT（往返时间）动态计算
* 超时 → 重传

### **② 快速重传（3 个重复 ACK）**

当接收方收到乱序包时会持续返回同一个 ACK：

```
ACK100, ACK100, ACK100 → 触发快速重传
```

无需等待超时。

### **③ SACK（Selective ACK）选择性确认**

* 在 Options 里
* 允许接收方告诉发送方仅丢了哪些段

提高重传效率。

---

# 7️ **流量控制（Sliding Window）**

通过 **窗口大小（Window Size）** 控制发送端速度：

```
发送窗口 = min(对方窗口, 拥塞窗口)
```

如果接收方处理慢，

```
window = 0
```

→ 发送方必须停止，等待窗口更新。

---

# 8️ **拥塞控制（四大算法）**

控制网络拥塞：

### **① 慢启动 Slow Start**

cwnd 从 1 MSS 开始指数增长：

1 → 2 → 4 → 8 → 16 …

### **② 拥塞避免 Congestion Avoidance**

到达 ssthresh 后线性增长：

cwnd++ per RTT

### **③ 快速重传 Fast Retransmit**

收到 3 个重复 ACK

### **④ 快速恢复 Fast Recovery**

不回到慢启动
cwnd 降一半继续线性增长

---

# 9️ **TIME_WAIT、CLOSE_WAIT 问题**

### **TIME_WAIT（常见问题）**

* 客户端主动关闭后进入
* 持续 *2MSL*（一般为 60 秒）
* 作用：

  * 防止旧包干扰新的连接
  * 确保最后一个 ACK 被对方收到

太多 TIME_WAIT 会导致端口耗尽。

---

### **CLOSE_WAIT（更严重）**

* 这是 **服务端没关闭 socket** 导致的
* 根因：程序没有调用 `close()`
* 会撑满 FD，导致服务器崩溃

---

# 10 **实战：Wireshark TCP 数据流分析图**

一个典型数据流：

```
SYN
SYN-ACK
ACK
PSH,ACK (发送数据)
ACK (确认)
FIN
ACK
FIN
ACK
```

你可以根据 Seq / Ack 来判断：

* 哪个包丢了
* 是否快速重传
* 是否零窗口
* 延迟是否增大
* 是否拥塞控制触发

---

#  总结（记住这几句话就够用）

1. **TCP 用 Seq/Ack 实现可靠传输**
2. **窗口控制发送速率（流控）**
3. **拥塞控制保护网络（慢启动、拥塞避免）**
4. **三次握手建立连接，四次挥手关闭连接**
5. **TIME_WAIT 是正常的，CLOSE_WAIT 是程序 bug**
6. **快速重传通过重复 ACK 提高效率**

---

如果你需要，我还可以为你补充：

✅ 一张完整的 **TCP 全流程图（从握手到数据流到关闭）**
✅ 一份 **TCP 与 UDP 对比表（运维/开发面试常问）**
✅ 一份 **TCP 抓包分析实战案例（带图）**

你需要哪一部分？
