# **TCP 三次握手 + 四次挥手详解**
包含：
* 每一步的动作
* Seq/Ack 如何变化
* 为什么需要 3 次 / 4 次
* 常见错误理解纠正
* 抓包时如何判断状态

内容非常完整，看完你就能在面试和工作中讲得非常专业。

---

#  一、TCP 三次握手（建立连接）

三次握手的核心目标：

1. **确认双方收发能力正常**
2. **协商初始序列号 ISN**（随机）
3. **建立可靠、全双工通信通道**

---

# 1️ 第一次握手：客户端 → SYN

```
Client  →  SYN(seq = x)  →  Server
```

客户端发送：

* **SYN = 1**
* **序列号 seq = x**
* 告诉服务端：“我要建立连接，并从序列 x 开始发数据。”

服务端收到后知道：

* ✔ 客户端发送正常

---

# 2️ 第二次握手：服务端 → SYN + ACK

```
Client  ←  SYN(seq = y), ACK = x+1  ←  Server
```

服务端发送：

* **SYN = 1**（我也同意建立连接）
* **ACK = x + 1**（收到你的 SYN 了，请发下一个序号）
* **seq = y**（这是我这边的初始序列号）

客户端收到后知道：

* ✔ 服务端收到了我的 SYN
* ✔ 服务端也能发数据

---

# 3️ 第三次握手：客户端 → ACK

```
Client  →  ACK(ack = y+1)  →  Server
```

客户端回复：

* **ACK = y + 1**（收到你的 SYN）
* 正式确认连接建立

服务端收到后知道：

* ✔ 客户端能收到我的信息
*  连接真正建立

---

#  三次握手总结图

```
Client                              Server
   | --------- SYN(seq=x) ---------> |
   | <---- SYN(seq=y), ACK=x+1 ----- |
   | -------- ACK(ack=y+1) --------> |
```

---

#  为什么不是两次握手？

因为无法确保：

* 客户端的 ACK 能正常到达服务器
* 防止已失效的旧 SYN 包重新建立连接（安全问题）
* 双方序列号需要双向确认（双向通道）

所以必须 **三次握手**。

---

#  面试重点：三次握手之后双方的状态？

* **client → ESTABLISHED**
* **server → ESTABLISHED**

连接正式建立，后续即可双向传输数据。

---

#  二、TCP 四次挥手（断开连接）

为什么需要4次？
因为**TCP 是全双工的**，关闭一个方向需要一个 FIN，两边都关闭共两个 FIN，所以总共 **4 个报文段**。

---

# 1️ 第一次挥手：客户端 → FIN

```
Client  →  FIN(seq = u)  →  Server
```

含义：

* 客户端说：“我这边数据发送完了，不再发了。”

服务端收到后 → 进入 `CLOSE_WAIT`（需要继续给客户端发数据）

---

# 2️ 第二次挥手：服务端 → ACK

```
Client  ←  ACK(ack = u+1)  ←  Server
```

此时：

* 服务端还没关闭，是半关闭状态（服务器仍可发数据）
* 客户端进入 `FIN_WAIT_2` 状态

---

# 3️ 第三次挥手：服务端 → FIN

当服务端也发完数据后：

```
Client  ←  FIN(seq = v)  ←  Server
```

服务端说：“我也发完了，你可以关了。”

客户端进入 `TIME_WAIT` 状态（非常关键）

---

# 4️ 第四次挥手：客户端 → ACK

```
Client  →  ACK(ack = v+1)  →  Server
```

服务端收到 ACK → 直接关闭连接。

客户端保持 `TIME_WAIT` 2MSL（通常 1–2 分钟）后关闭连接。

---

#  四次挥手总结图

```
Client                                       Server
   | -------- FIN(seq=u) ------------------> |
   | <---------------- ACK(u+1) ------------ |
   | <------------- FIN(seq=v) ------------- |
   | -------- ACK(v+1) --------------------> |
```

---

#  为什么需要 TIME_WAIT？

客户端主动关闭 → 必须进入 **TIME_WAIT**。

作用：

1. **确保最后一个 ACK 能被对方收到**（否则对方重发 FIN）
2. **防止旧连接的报文影响新连接**（端口重用安全）

如果没有 TIME_WAIT，新连接会被旧包干扰。

---

# ❗ CLOSE_WAIT 说明（常见服务端 bug）

* 如果服务端收到 FIN 后不发送自己的 FIN
* 连接会永远停在 **CLOSE_WAIT**

原因：服务端程序没调用 `close()`
表现：大量 CLOSE_WAIT → 服务端会把 FD 用光 → 故障！

---

#  总结（记住这些就能讲得很专业）

**三次握手**

* SYN → SYN+ACK → ACK
* 双向确认序列号 + 收发能力
* 防止旧连接建立（安全）

**四次挥手**

* FIN → ACK → FIN → ACK
* 因为双向关闭必须各发一个 FIN
* TIME_WAIT 是客户端的保护机制
* CLOSE_WAIT 通常是服务端代码问题

---

如果你愿意，我还可以给你：

📌 **完整的 Wireshark 抓包显示握手/挥手的图示**
📌 **三次握手为什么不能减少为两次？（面试深度版）**
📌 **四次挥手合并成三次的情况（常见优化）**
📌 **TCP 状态机图（非常直观）**

你想继续看哪部分？
