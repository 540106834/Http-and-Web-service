# 为什么选择走TLS

**当浏览器或客户端准备访问一个网址时，它怎么知道要不要走 TLS？这个问题像“敲门前要不要穿盔甲”一样关键。下面我们把这个机制拆开，让你从电路板到应用层都看清楚**



## 1. **由 URL 决定（应用层）**

客户端最上层逻辑先看到的是 **协议头**：

- `https://example.com` → 必须走 TLS
- `http://example.com` → 不走 TLS

浏览器、curl、Java、Go、Python 的 HTTP 客户端都是按照 URL 决定是否开启 TLS 握手。

**这个是最核心的选择点。**

------

## 2. **由端口暗示（常规约定，不是强制）**

常见的默认绑定：

- `443` → 默认认为是 TLS
- `80` → 默认认为是明文 HTTP

如果你访问：

```
GET https://example.com:80
```

浏览器依旧会走 TLS，因为 **URL 优先级高于端口**。

如果访问：

```
http://example.com:443
```

浏览器则尝试明文 HTTP，服务器通常会断开。

------

## 3. **TCP 层根本不知道 TLS 存在**

更底层的 TCP 不区分 “明文包” 还是 “TLS 包”。

对它来说：

> 只是字节流。

没有任何标记、没有 flag、没有 header。

------

## 4. **识别 TLS 的方法：从第一个字节读出魔术字**

虽然 TCP 不判断，但服务器在读到第一个字节时，就能判断对方是不是 TLS。

TLS ClientHello 开头是一个固定结构：

```
0x16  （Handshake 类型）
0x03 0x01 / 0x03 0x03 / 0x03 0x04  （TLS version）
```

Server 会这样判断：

- 如果收到以 `0x16 0x03 xx` 开头 → 这是 TLS ClientHello → 按 TLS 解析
- 如果收到明文如 `GET / HTTP/1.1` → 明文 HTTP

这属于 **协议魔术字识别**。

你可以理解为：

> Server 读到第一句话，就知道对方穿的是盔甲还是便服。



# 总结成一句话

> 客户端根据 URL 决定“要不要穿 TLS”，服务器根据第一个字节判断“对方穿的是不是 TLS”。

